/**************************************************************************************

Copyright Â© 2004-2011 VMware, Inc. All rights reserved.

**************************************************************************************/

#include "photoscenario.h"
#include "teststream.h"

// Implement this test.
int	PhotoScenario::execute()
{
	// Initialize all the properties and classes		
	mPinCount = 1000 ;
	mTagCount = 10;
	mCreateTagPINs = true ;
	mFolderCount = 100;
	mNumPINsPerFolder = 200;
	mCreateAppPINs = false;
	mParentFolder = false;
	mCreateACLs = true ;
	mNotificationMeta = (CLASS_NOTIFY_JOIN | CLASS_NOTIFY_LEAVE | CLASS_NOTIFY_CHANGE | CLASS_NOTIFY_DELETE | CLASS_NOTIFY_NEW);
	mHostID = "yasir.pinexus.com" ;

	// Test can override, but they don't have a session yet
	preTestInitialize(); 

	if (MVTApp::startStore(NULL,mEnableNotifCB?this:NULL))
	{
		mSession = MVTApp::startSession();
		mStoreCtx = MVTApp::getStoreCtx();

		// Test can do post-session overrides
		initializeTest();
		
		registerProperties() ;

		// Generate Meta - Folders		
		generateFolderPathPool( mFolderCount ) ;
		
		createPhotoClasses() ;

		// Actual derived tests will implement these
		populateStore() ;
		doTest() ;

		mSession->terminate();
		mSession = NULL ;
		MVTApp::stopStore();
	}
	else
	{
		TVERIFY(!"Unable to start or create store") ;
	}

	return RC_OK  ;
}

void PhotoScenario::registerProperties()
{
	// Register and remember the common properties as member variables
	mime_id = getProp("mime_id" );
	name_id = getProp("name" );
	tag_id = getProp("tag" );
	date_id = getProp("date" );
	binary_id = getProp("binary" );
	imgStatus_id = getProp("imgStatus" );
	fs_path_id = getProp("fs_path" );
	cache_id = getProp("cache" );
	refreshNodeID_id = getProp("refresh-node-id" );
	prop_system_id = getProp("prop_system");
	feed_id = getProp("feed_id");
	feedinfo_id = getProp("feedinfo");
	feedtype_id = getProp("feedtype");
	fs_folder_id = getProp("fs_folder");
	acceptemail_id = getProp("acceptemail");
	tagword_id = getProp("tagword");
	shortname_id = getProp("shortname");
	posts_id = getProp("posts");
	cluster_id = getProp("cluster_id");
	email_id = getProp("email_id");
	visIdentity_id = getProp("vidIdentity");
	tabname_id = getProp("tabname");
	owner_id_id = getProp("owner");
	owner_name_id = getProp("owner_name");
	lastmodified_id= getProp("lastmodified");
	created_id= getProp("created");
	exif_model_id= getProp("exif_model");
	exif_fnumber_id= getProp("exif_fnumber");
	exif_picturetaken_id= getProp("exif_picturetaken");
	exif_exposuretime_id= getProp("exif_exposuretime");
	exif_isospeedratings_id= getProp("exif_isospeedratings");
	exif_flash_id= getProp("exif_flash");
	width_id= getProp("width");
	height_id= getProp("height");
	preview_id= getProp("preview");
	exif_make_id= getProp("exif_make");
	fs_path_index_id= getProp("fs_path_index");
	exif_width_id= getProp("exif_width");
	exif_height_id= getProp("exif_height");
	sourcenode_id= getProp("sourcenode");	
	feedautorefresh_id= getProp("feedautorefresh");
	feedfullsize_id= getProp("feedfullsize");
	feedimportsubfolder_id= getProp("feedimportsubfolder");
	feedflattensubfolder_id= getProp("feedflattensubfolder");
	autogen_id= getProp("autogen");
	content_id= getProp("content");
	autogenerated_id= getProp("autogenerated");
	photo_count_id= getProp("photo_count");
	album_count_id= getProp("album_count");
	tagcount_id = getProp("tagcount");
	mvstoreexTS_id = getProp("mvstoreex.timestamp");
}

PropertyID PhotoScenario::getProp( const char * inAppName )
{
	// Convenient function to turn string name of a property to 
	// its property id
	return MVTApp::getProp(mSession,string(inAppName+mPostfix).c_str()) ;
}

ClassID PhotoScenario::getClass( const char * inClassName, ISession *pSession)
{
	return MVTApp::getClass(pSession==NULL?mSession:pSession,string(inClassName+mPostfix).c_str()) ;
}

PID PhotoScenario::addPhotoPin
( 
	const char * inName,		 // optional
	const char * inFSPath,		 // optional
	uint64_t inDate,			 // optional
	unsigned long inStrmsize,	 // optional
	bool	bCreateMixed
)
{
	// Add fake photo pin using random values.
	// 

	Value vals[7] ;
	std::string randPath ;
	std::string fileName ;

	if ( inName == NULL )
	{
		MVTRand::getString( fileName, 10, 40, true /*words*/ ) ;
		fileName += ".JPG" ;
		vals[0].set( fileName.c_str() ) ; vals[0].property = name_id ;
	}
	else
	{
		fileName = inName ;
		vals[0].set( inName ) ; vals[0].property = name_id ;
	}

	if ( inFSPath == NULL )
	{
		assert( !mFilePathPool.empty() ) ;
		size_t index = MVTRand::getRange(0,(int)(mFilePathPool.size()-1)) ;
		randPath = mFilePathPool[index] ; 
		randPath += fileName ; 

		vals[1].set( randPath.c_str() ) ; 
		vals[1].property = fs_path_id ;
	}
	else
	{
		vals[1].set( inFSPath ) ; vals[1].property = fs_path_id ;
	}

	if ( inStrmsize == 0 ) 
		inStrmsize = MVTRand::getRange(1,10000) ;

	IStream *lStream = MVTApp::wrapClientStream(mSession,new TestStringStream(inStrmsize,VT_BSTR));
	vals[2].set( lStream ) ; vals[2].property=binary_id ; vals[2].meta = META_PROP_NOFTINDEX | META_PROP_SSTORAGE;

	if ( inDate == 0 )
		inDate = MVTRand::getDateTime(mSession) ;

	vals[3].setDateTime( inDate ) ; vals[3].property=date_id ; 
	vals[4].set( (int)MVTRand::getBool() ) ; vals[4].property=cache_id ; 
	vals[5].set( mHostID.c_str() ) ; vals[5].property=refreshNodeID_id ; 
	vals[6].set("image/jpeg") ; vals[6].property=mime_id ; 

	PID newpin ;
	TVERIFYRC( mSession->createPIN( newpin, vals, 7 ) );

	if (bCreateMixed && MVTRand::getBool() )
	{
		// Provide some random coverage of this clause:
		//    ((pin has imgStatus_id and imgStatus_id = 0) or !(pin has imgStatus_id))
		Value status ;
		status.set( (int)MVTRand::getBool() ) ; status.property = imgStatus_id ;
		TVERIFYRC(mSession->modifyPIN( newpin, &status, 1 )) ;
	}

	return newpin ;
}

void PhotoScenario::generateFolderPathPool( size_t cntFolders )
{
	// Build a list of fake file system like strings to represent
	// different directories that the images were imported from

	mFilePathPool.clear() ;
	string lMainFolder;
	MVTRand::getString(lMainFolder,10,10,true/*words*/,false/*case*/);
	lMainFolder.append("/");

	for ( size_t i = 0 ; i < cntFolders ; i++ )
	{
		string path ;
#ifdef WIN32
		path = "c:/" ;  // Actual Photo app uses "/" slash even on windows
#else
		path = "/" ;
#endif
		if(mParentFolder) path.append(lMainFolder);
		if(mParentFolder && i == 0) mFilePathPool.push_back(path);

		for ( size_t k = 0 ; k < 4 ; k++ )
		{
			string folder ;
			MVTRand::getString(folder,5,5,false/*words*/);
			path += folder ;
			path += "/" ;
		}
		mFilePathPool.push_back(path) ;
	}
}

void PhotoScenario::addRandomTags(size_t cntTagPool)
{
	// Generate some tags and then distribute them through the
	// test pins
	mTagPool.clear() ;
	for ( size_t i = 0 ; i < cntTagPool ; i++ )
	{
		string tag ;
		MVTRand::getString(tag,3,10,false/*words*/);

		// Create PIN for the tag (mTagPool, mTagPins)
		createTagPIN(tag.c_str());
	}

	assert( mTagPool.size() == cntTagPool ) ;

	// (First pin gets all the tags, other pins
	// have 0 to cntTagPool pins)
	for ( size_t k= 0 ; k < mTagPool.size() ; k++ )
	{	
		for ( size_t j = 0 ; j < getPinCount() ; )
		{		
			Value tag ;
			tag.set( mTagPool[k].c_str() ) ; tag.op = OP_ADD ; tag.property = tag_id ;

			TVERIFYRC( mSession->modifyPIN( mPids[j], &tag, 1 ) ) ;

			// Move ahead in the array
			j += MVTRand::getRange(1,50) ;
		}
	}
}

void PhotoScenario::populateStore()
{
	// Put some pins into the store

	mLogger.out() << "Generating " << (int) getPinCount() << " pins" << endl ;
	mPids.resize( getPinCount()) ;
	if(!mCreateAppPINs)
	{
		for ( size_t i = 0 ; i < getPinCount() ; i++ )
		{		
			if (0 == i % 100)
				mLogger.out() << ".";

			mPids[i] = addPhotoPin() ;
		}

		addRandomTags(10) ;
		mLogger.out() << endl ;
	}
	else
		if(!createAppPINs()) assert(false);
}

void PhotoScenario::setPostFix()
{
	MVTRand::getString(mPostfix,11,0,false);
	mPostfix[0] = '.' ;
}

void PhotoScenario::initializeTest()
{
	setPostFix();	
}
void PhotoScenario::preTestInitialize()
{
	mEnableNotifCB = false;	
}
void PhotoScenario::createPhotoClasses()
{
	// Creates classes that are extremely close to the ones used in the photo app

	// Not all classes are covered here, (photo app uses over 30 classes) but it can be extended 
	// and should be kept up to date with any definition changes.  See init.xq for more details.

	mLogger.out() << "Adding classes and families..." << endl ;

	string className ;

	// These ClassIDs can become member variables for easy usage in tests
	ClassID lCLSUncachedImageID = STORE_INVALID_CLASSID; //0
	{
		//Uncached Image   /pin[cache > 0 and pin has binary and refresh-node-id ="yasir.pinexus.com"]
		className = string("uncachedimage") + mPostfix ;
		if(RC_OK!=mSession->getClassID(className.c_str(),lCLSUncachedImageID))
		{
			CmvautoPtr<IStmt> lQ(mSession->createStmt());
			unsigned const char lVar = lQ->addVariable();
			
			Value lV[2];
			lV[0].setVarRef(0,cache_id);
			lV[1].set(0);
			IExprTree *lET1 = EXPRTREEGEN(mSession)(OP_GT, 2, lV);

			lV[0].setVarRef(0,refreshNodeID_id);
			lV[1].set(mHostID.c_str()); 
			IExprTree *lET2 = EXPRTREEGEN(mSession)(OP_EQ, 2, lV);	

			lV[0].set(lET1);
			lV[1].set(lET2);
			IExprTree *lET3 = EXPRTREEGEN(mSession)(OP_LAND, 2, lV);

			lV[0].setVarRef(0,binary_id);
			IExprTree *lET4 = EXPRTREEGEN(mSession)(OP_EXISTS, 1, lV);	

			lV[0].set(lET3);
			lV[1].set(lET4);
			CmvautoPtr<IExprTree> lET( mSession->expr(OP_LAND, 2, lV, 0));			

			TVERIFYRC(lQ->addCondition(lVar,lET));
			TVERIFYRC(defineClass(mSession,className.c_str(), lQ, &lCLSUncachedImageID));
		}
		TVERIFYRC(mSession->enableClassNotifications(lCLSUncachedImageID, mNotificationMeta));
	}

	ClassID lCLSSystemPinID = STORE_INVALID_CLASSID; //1
	{
		//mv:defineclass("systemPin","/pin[pin has prop_system]",0)
		className = string("systempin") + mPostfix ;
		if(RC_OK!=mSession->getClassID(className.c_str(),lCLSSystemPinID))
		{
			CmvautoPtr<IStmt> lQ(mSession->createStmt());
			unsigned const char lVar = lQ->addVariable();
			Value lV[1];
			lV[0].setVarRef(0,prop_system_id);
			CmvautoPtr<IExprTree> lET( mSession->expr(OP_EXISTS, 1, lV, 0));
			TVERIFYRC(lQ->addCondition(lVar,lET));

			TVERIFYRC(defineClass(mSession,className.c_str(), lQ, &lCLSSystemPinID));
		}
		TVERIFYRC(mSession->enableClassNotifications(lCLSSystemPinID, mNotificationMeta));
	}

	ClassID lFamilyFeedID = STORE_INVALID_CLASSID;//2
	{
		//mv:defineclass("feed($var)","/pin[pin has feedinfo and feedtype = $var]",0)
		className = string("feed") + mPostfix ;
		if(RC_OK!=mSession->getClassID(className.c_str(),lFamilyFeedID))
		{
			CmvautoPtr<IStmt> lQ(mSession->createStmt());
			unsigned char lVar = lQ->addVariable();		
		
			Value lV[2];
			lV[0].setVarRef(0,feedinfo_id);
			IExprTree *lET1 = EXPRTREEGEN(mSession)(OP_EXISTS, 1, lV);

			lV[0].setVarRef(0,feedtype_id);
			lV[1].setParam(0);
			IExprTree *lET2 = EXPRTREEGEN(mSession)(OP_EQ, 2, lV);		
			
			lV[0].set(lET1);
			lV[1].set(lET2);
			CmvautoPtr<IExprTree> lET( mSession->expr(OP_LAND, 2, lV, 0));			

			TVERIFYRC(lQ->addCondition(lVar,lET));
			TVERIFYRC(defineClass(mSession,className.c_str(), lQ, &lFamilyFeedID));
		}
		TVERIFYRC(mSession->enableClassNotifications(lFamilyFeedID, mNotificationMeta));
	}

	ClassID lCLSRSSFeedID = STORE_INVALID_CLASSID;//3
	{
		//mv:defineclass("rssFeed","/pin[pin has feed and feedType = 3]",0)
		className = string("rssFeed") + mPostfix ;
		if(RC_OK!=mSession->getClassID(className.c_str(),lCLSRSSFeedID))
		{
			CmvautoPtr<IStmt> lQ(mSession->createStmt());
			unsigned char lVar = lQ->addVariable();		
		
			Value lV[2];
			lV[0].setVarRef(0,feed_id);
			IExprTree *lET1 = EXPRTREEGEN(mSession)(OP_EXISTS, 1, lV);

			lV[0].setVarRef(0,feedtype_id);
			lV[1].set(3);
			IExprTree *lET2 = EXPRTREEGEN(mSession)(OP_EQ, 2, lV);		
			
			lV[0].set(lET1);
			lV[1].set(lET2);
			CmvautoPtr<IExprTree> lET( mSession->expr(OP_LAND, 2, lV, 0));			

			TVERIFYRC(lQ->addCondition(lVar,lET));
			TVERIFYRC(defineClass(mSession,className.c_str(), lQ, &lCLSRSSFeedID));
		}
		TVERIFYRC(mSession->enableClassNotifications(lCLSRSSFeedID, mNotificationMeta));
	}

	ClassID lCLSEmailFeedID = STORE_INVALID_CLASSID;//4
	{
		//mv:defineclass("emailFeed","/pin[feedType = 2 and acceptemail = 1]",0)
		className = string("emailFeed") + mPostfix ;
		if(RC_OK!=mSession->getClassID(className.c_str(),lCLSEmailFeedID))
		{
			CmvautoPtr<IStmt> lQ(mSession->createStmt());
			unsigned char lVar = lQ->addVariable();		
		
			Value lV[2];
			lV[0].setVarRef(0,feedtype_id);
			lV[1].set(2);
			IExprTree *lET1 = EXPRTREEGEN(mSession)(OP_EQ, 2, lV);	

			lV[0].setVarRef(0,acceptemail_id);
			lV[1].set(1);
			IExprTree *lET2 = EXPRTREEGEN(mSession)(OP_EQ, 2, lV);
			
			lV[0].set(lET1);
			lV[1].set(lET2);
			CmvautoPtr<IExprTree> lET( mSession->expr(OP_LAND, 2, lV, 0));			

			TVERIFYRC(lQ->addCondition(lVar,lET));
			TVERIFYRC(defineClass(mSession,className.c_str(), lQ, &lCLSEmailFeedID));
		}
		TVERIFYRC(mSession->enableClassNotifications(lCLSEmailFeedID, mNotificationMeta));
	}
	
	ClassID lCLSTagID = STORE_INVALID_CLASSID; //5
	{
		////mv:defineclass("tag","/pin[pin has tagword]",0)
		className = string("tag") + mPostfix ;
		if(RC_OK!=mSession->getClassID(className.c_str(),lCLSTagID))
		{
			CmvautoPtr<IStmt> lQ(mSession->createStmt());
			unsigned const char lVar = lQ->addVariable();
			Value lV[1];
			lV[0].setVarRef(0,tagword_id);
			CmvautoPtr<IExprTree> lET( mSession->expr(OP_EXISTS, 1, lV, 0));
			TVERIFYRC(lQ->addCondition(lVar,lET));

			TVERIFYRC(defineClass(mSession,className.c_str(), lQ, &lCLSTagID));
		}
		TVERIFYRC(mSession->enableClassNotifications(lCLSTagID, mNotificationMeta));
	}

	ClassID lCLSTaggedPinID = STORE_INVALID_CLASSID; //6
	{
		//taggedPin  /pin[pin has tag_id]
		className = string("taggedPin") + mPostfix ;
		if(RC_OK!=mSession->getClassID(className.c_str(),lCLSTaggedPinID))
		{
			CmvautoPtr<IStmt> lQ(mSession->createStmt());
			unsigned const char lVar = lQ->addVariable();
			Value lV[1];
			lV[0].setVarRef(0,tag_id);
			CmvautoPtr<IExprTree> lET( mSession->expr(OP_EXISTS, 1, lV, 0));
			TVERIFYRC(lQ->addCondition(lVar,lET));

			TVERIFYRC(defineClass(mSession,className.c_str(), lQ, &lCLSTaggedPinID));
		}
		TVERIFYRC(mSession->enableClassNotifications(lCLSTaggedPinID, mNotificationMeta));
	}

	ClassID lCLSAlbumID = STORE_INVALID_CLASSID; //7
	{
		//	mv:defineclass("album","/pin[pin has name and (pin has shortname or pin has posts)]",0)
		className = string("album") + mPostfix ;
		if(RC_OK!=mSession->getClassID(className.c_str(),lCLSAlbumID))
		{
			CmvautoPtr<IStmt> lQ(mSession->createStmt());
			unsigned const char lVar = lQ->addVariable();
			Value lV[2];
			lV[0].setVarRef(0,name_id);
			IExprTree *lET1 = mSession->expr(OP_EXISTS, 1, lV, 0);

			lV[0].setVarRef(0,shortname_id);
			IExprTree *lET2 = mSession->expr(OP_EXISTS, 1, lV, 0);

			lV[0].setVarRef(0,posts_id);
			IExprTree *lET3 = mSession->expr(OP_EXISTS, 1, lV, 0);

			lV[0].set(lET2);
			lV[1].set(lET3);
			IExprTree *lET4 = mSession->expr(OP_LAND, 2, lV, 0);	

			lV[0].set(lET1);
			lV[1].set(lET4);
			CmvautoPtr<IExprTree> lET(mSession->expr(OP_LAND, 2, lV, 0));

			TVERIFYRC(lQ->addCondition(lVar,lET));

			TVERIFYRC(defineClass(mSession,className.c_str(), lQ, &lCLSAlbumID));
		}
		TVERIFYRC(mSession->enableClassNotifications(lCLSAlbumID, mNotificationMeta));
	}

	ClassID lCLSSearchSetID = STORE_INVALID_CLASSID; //8
	{
		//	mv:defineclass("searchSet","/pin[pin has name and (pin has shortname or pin has posts) and !(pin has prop_system)]",0)
		className = string("searchSet") + mPostfix ;
		if(RC_OK!=mSession->getClassID(className.c_str(),lCLSSearchSetID))
		{
			CmvautoPtr<IStmt> lQ(mSession->createStmt());
			unsigned const char lVar = lQ->addVariable();
			Value lV[2];
			lV[0].setVarRef(0,name_id);
			IExprTree *lET1 = mSession->expr(OP_EXISTS, 1, lV, 0);

			lV[0].setVarRef(0,shortname_id);
			IExprTree *lET2 = mSession->expr(OP_EXISTS, 1, lV, 0);

			lV[0].setVarRef(0,posts_id);
			IExprTree *lET3 = mSession->expr(OP_EXISTS, 1, lV, 0);

			lV[0].set(lET2);
			lV[1].set(lET3);
			IExprTree *lET4 = mSession->expr(OP_LAND, 2, lV, 0);

			lV[0].setVarRef(0,prop_system_id);
			IExprTree *lET5 = mSession->expr(OP_EXISTS, 1, lV, 0);

			lV[0].set(lET5);
			IExprTree *lET6 = mSession->expr(OP_LNOT, 1, lV, 0);			

			lV[0].set(lET1);
			lV[1].set(lET4);
			IExprTree *lET7 = mSession->expr(OP_LAND, 2, lV, 0);

			lV[0].set(lET7);
			lV[1].set(lET6);
			CmvautoPtr<IExprTree> lET(mSession->expr(OP_LAND, 2, lV, 0));

			TVERIFYRC(lQ->addCondition(lVar,lET));

			TVERIFYRC(defineClass(mSession,className.c_str(), lQ, &lCLSSearchSetID));
		}
		TVERIFYRC(mSession->enableClassNotifications(lCLSSearchSetID, mNotificationMeta));
	}

	ClassID lCLSImageID = STORE_INVALID_CLASSID; //9
	{
		className = string("image") + mPostfix ;
		if(RC_OK!=mSession->getClassID(className.c_str(),lCLSImageID))
		{
			// pins where mime_id contains "image"
			CmvautoPtr<IStmt> lQ(mSession->createStmt());
			unsigned const char lVar = lQ->addVariable();
			Value lV[2];
			lV[0].setVarRef(0,mime_id);
			lV[1].set("image");
			CmvautoPtr<IExprTree> lET( mSession->expr(OP_CONTAINS, 2, lV, CASE_INSENSITIVE_OP));
			TVERIFYRC(lQ->addCondition(lVar,lET));

			TVERIFYRC(defineClass(mSession,className.c_str(), lQ, &lCLSImageID));
		}
		TVERIFYRC(mSession->enableClassNotifications(lCLSImageID, mNotificationMeta));
	}

	ClassID lCLSListID = STORE_INVALID_CLASSID; //10
	{
		//mv:defineclass("list","/pin[pin has posts]",0)
		className = string("list") + mPostfix ;
		if(RC_OK!=mSession->getClassID(className.c_str(),lCLSListID))
		{
			CmvautoPtr<IStmt> lQ(mSession->createStmt());
			unsigned const char lVar = lQ->addVariable();
			Value lV[1];
			lV[0].setVarRef(0,posts_id);
			CmvautoPtr<IExprTree> lET( mSession->expr(OP_EXISTS, 1, lV, 0));
			TVERIFYRC(lQ->addCondition(lVar,lET));

			TVERIFYRC(defineClass(mSession,className.c_str(), lQ, &lCLSListID));
		}
		TVERIFYRC(mSession->enableClassNotifications(lCLSListID, mNotificationMeta));
	}

	ClassID lCLSClusterParentID = STORE_INVALID_CLASSID; //11
	{
		//	mv:defineclass("clusterparent","/pin[pin has cluster]",0)
		className = string("clusterparent") + mPostfix ;
		if(RC_OK!=mSession->getClassID(className.c_str(),lCLSClusterParentID))
		{
			CmvautoPtr<IStmt> lQ(mSession->createStmt());
			unsigned const char lVar = lQ->addVariable();
			Value lV[1];
			lV[0].setVarRef(0,cluster_id);
			CmvautoPtr<IExprTree> lET( mSession->expr(OP_EXISTS, 1, lV, 0));
			TVERIFYRC(lQ->addCondition(lVar,lET));

			TVERIFYRC(defineClass(mSession,className.c_str(), lQ, &lCLSClusterParentID));
		}
		TVERIFYRC(mSession->enableClassNotifications(lCLSClusterParentID, mNotificationMeta));
	}

	ClassID lCLSImportedFileID = STORE_INVALID_CLASSID;//12
	{
		//importedFile  /pin[pin has fs_path]
		className = string("importedFile") + mPostfix ;
		if(RC_OK!=mSession->getClassID(className.c_str(),lCLSImportedFileID))
		{
			CmvautoPtr<IStmt> lQ(mSession->createStmt());
			unsigned const char lVar = lQ->addVariable();
			Value lV[1];
			lV[0].setVarRef(0,fs_path_id);
			CmvautoPtr<IExprTree> lET( mSession->expr(OP_EXISTS, 1, lV, 0));
			TVERIFYRC(lQ->addCondition(lVar,lET));

			TVERIFYRC(defineClass(mSession,className.c_str(), lQ, &lCLSImportedFileID));
		}
		TVERIFYRC(mSession->enableClassNotifications(lCLSImportedFileID, mNotificationMeta));
	}

	ClassID lCLSImportedFolderID = STORE_INVALID_CLASSID;//13
	{
		//mv:defineclass("importedFolder","/pin[pin has fs_folder]",0)]
		className = string("importedFolder") + mPostfix ;
		if(RC_OK!=mSession->getClassID(className.c_str(),lCLSImportedFolderID))
		{
			CmvautoPtr<IStmt> lQ(mSession->createStmt());
			unsigned const char lVar = lQ->addVariable();
			Value lV[1];
			lV[0].setVarRef(0,fs_folder_id);
			CmvautoPtr<IExprTree> lET( mSession->expr(OP_EXISTS, 1, lV, 0));
			TVERIFYRC(lQ->addCondition(lVar,lET));

			TVERIFYRC(defineClass(mSession,className.c_str(), lQ, &lCLSImportedFolderID));
		}
		TVERIFYRC(mSession->enableClassNotifications(lCLSImportedFolderID, mNotificationMeta));
	}

	ClassID lCLSSubscriptionID = STORE_INVALID_CLASSID;//14
	{
		//mv:defineclass("subscription","/pin[pin has feed]",0)
		className = string("subscription") + mPostfix ;
		if(RC_OK!=mSession->getClassID(className.c_str(),lCLSSubscriptionID))
		{
			CmvautoPtr<IStmt> lQ(mSession->createStmt());			
			unsigned const char lVar = lQ->addVariable();		

			Value lV[2];
			lV[0].setVarRef(0,feed_id);
			CmvautoPtr<IExprTree> lET( mSession->expr( OP_EXISTS, 1, lV, 0));

			TVERIFYRC(lQ->addCondition(lVar,lET));		
			TVERIFYRC(defineClass(mSession,className.c_str(), lQ, &lCLSSubscriptionID));
		}
		TVERIFYRC(mSession->enableClassNotifications(lCLSSubscriptionID, mNotificationMeta));
	}

	ClassID lCLSSubscriptionQueueID = STORE_INVALID_CLASSID;//15
	{
		//mv:defineclass("subscriptionqueue","/pin[name = 'subscriptionqueue' and prop_system = 'true']",0)
		className = string("subscriptionqueue") + mPostfix ;
		if(RC_OK!=mSession->getClassID(className.c_str(),lCLSSubscriptionQueueID))
		{
			CmvautoPtr<IStmt> lQ(mSession->createStmt());			
			unsigned const char lVar = lQ->addVariable();		

			Value lV[2];
			lV[0].setVarRef(0,name_id);
			lV[1].set("subscriptionqueue");
			IExprTree *lET1 = mSession->expr( OP_EQ, 2, lV, 0);

			lV[0].setVarRef(0,prop_system_id);
			lV[1].set("true");
			IExprTree *lET2 = mSession->expr( OP_EQ, 2, lV, 0);

			lV[0].set(lET1);
			lV[1].set(lET2);
			CmvautoPtr<IExprTree> lET( mSession->expr( OP_LAND, 2, lV, 0));

			TVERIFYRC(lQ->addCondition(lVar,lET));		
			TVERIFYRC(defineClass(mSession,className.c_str(), lQ, &lCLSSubscriptionQueueID));
		}
		TVERIFYRC(mSession->enableClassNotifications(lCLSSubscriptionQueueID, mNotificationMeta));
	}

	ClassID lCLSSubscriptionListID = STORE_INVALID_CLASSID;//16
	{
		//mv:defineclass("subscriptionlist","/pin[name = 'subscriptionslist' and prop_system = 'true']",0)
		className = string("subscriptionlist") + mPostfix ;
		if(RC_OK!=mSession->getClassID(className.c_str(),lCLSSubscriptionListID))
		{
			CmvautoPtr<IStmt> lQ(mSession->createStmt());			
			unsigned const char lVar = lQ->addVariable();		

			Value lV[2];
			lV[0].setVarRef(0,name_id);
			lV[1].set("subscriptionlist");
			IExprTree *lET1 = mSession->expr( OP_EQ, 2, lV, 0);

			lV[0].setVarRef(0,prop_system_id);
			lV[1].set("true");
			IExprTree *lET2 =  mSession->expr( OP_EQ, 2, lV, 0);

			lV[0].set(lET1);
			lV[1].set(lET2);
			CmvautoPtr<IExprTree> lET( mSession->expr( OP_LAND, 2, lV, 0));

			TVERIFYRC(lQ->addCondition(lVar,lET));		
			TVERIFYRC(defineClass(mSession,className.c_str(), lQ, &lCLSSubscriptionListID));
		}
		TVERIFYRC(mSession->enableClassNotifications(lCLSSubscriptionListID, mNotificationMeta));
	}

	ClassID lCLSContactID = STORE_INVALID_CLASSID; //17
	{
		//mv:defineclass("contact","/pin[pin has posts]",0)
		className = string("list") + mPostfix ;
		if(RC_OK!=mSession->getClassID(className.c_str(),lCLSContactID))
		{
			CmvautoPtr<IStmt> lQ(mSession->createStmt());
			unsigned const char lVar = lQ->addVariable();
			Value lV[1];
			lV[0].setVarRef(0,email_id);
			CmvautoPtr<IExprTree> lET( mSession->expr(OP_EXISTS, 1, lV, 0));
			TVERIFYRC(lQ->addCondition(lVar,lET));

			TVERIFYRC(defineClass(mSession,className.c_str(), lQ, &lCLSContactID));
		}
		TVERIFYRC(mSession->enableClassNotifications(lCLSContactID, mNotificationMeta));
	}

	ClassID lCLSVisFavAlbumID = STORE_INVALID_CLASSID; //18
	{
		//	mv:defineclass("VisFavAlbum","/pin[pin has visIdentity and pin has name and (pin has shortname or pin has posts)]",0)
		className = string("VisFavAlbum") + mPostfix ;
		if(RC_OK!=mSession->getClassID(className.c_str(),lCLSVisFavAlbumID))
		{
			CmvautoPtr<IStmt> lQ(mSession->createStmt());
			unsigned const char lVar = lQ->addVariable();
			Value lV[2];
			lV[0].setVarRef(0,visIdentity_id);
			IExprTree *lET1 = mSession->expr(OP_EXISTS, 1, lV, 0);

			lV[0].setVarRef(0,name_id);
			IExprTree *lET2 = mSession->expr(OP_EXISTS, 1, lV, 0);

			lV[0].setVarRef(0,shortname_id);
			IExprTree *lET3 = mSession->expr(OP_EXISTS, 1, lV, 0);

			lV[0].setVarRef(0,posts_id);
			IExprTree *lET4 = mSession->expr(OP_EXISTS, 1, lV, 0);

			lV[0].set(lET3);
			lV[1].set(lET4);
			IExprTree *lET5 = mSession->expr(OP_LOR, 2, lV, 0);

			lV[0].set(lET1);
			lV[1].set(lET2);
			IExprTree *lET6 = mSession->expr(OP_LAND, 2, lV, 0);

			lV[0].set(lET6);
			lV[1].set(lET5);
			CmvautoPtr<IExprTree> lET(mSession->expr(OP_LAND, 2, lV, 0));

			TVERIFYRC(lQ->addCondition(lVar,lET));

			TVERIFYRC(defineClass(mSession,className.c_str(), lQ, &lCLSVisFavAlbumID));
		}
		TVERIFYRC(mSession->enableClassNotifications(lCLSVisFavAlbumID, mNotificationMeta));
	}

	ClassID lFamilyImageClusterID = STORE_INVALID_CLASSID;//19
	{
		//imageCluster  /pin[pin is image() and date in $dateRange]
		className = string("imageCluster") + mPostfix ;
		if(RC_OK!=mSession->getClassID(className.c_str(),lFamilyImageClusterID))
		{
			CmvautoPtr<IStmt> lQ(mSession->createStmt());
			ClassSpec lRange[1];
			lRange[0].classID = lCLSImageID;
			lRange[0].nParams = 0;
			lRange[0].params = NULL;
			unsigned const char lVar = lQ->addVariable(lRange,1);		

			Value lV[2];
			lV[0].setVarRef(0,date_id);
			lV[1].setParam(0);
			CmvautoPtr<IExprTree> lET( mSession->expr(OP_IN, 2, lV, 0));

			TVERIFYRC(lQ->addCondition(lVar,lET));		
			TVERIFYRC(defineClass(mSession,className.c_str(), lQ, &lFamilyImageClusterID));
		}
		TVERIFYRC(mSession->enableClassNotifications(lFamilyImageClusterID, mNotificationMeta));
	}

	ClassID lFamilytaggedImagesID = STORE_INVALID_CLASSID;//20
	{
		//taggedImages  /pin[pin is image() and tag = $tagName]
		className = string("taggedImages") + mPostfix ;
		if(RC_OK!=mSession->getClassID(className.c_str(),lFamilytaggedImagesID))
		{
			CmvautoPtr<IStmt> lQ(mSession->createStmt());
			ClassSpec lRange[1];
			lRange[0].classID = lCLSImageID;
			lRange[0].nParams = 0;
			lRange[0].params = NULL;
			unsigned const char lVar = lQ->addVariable(lRange,1);		

			Value lV[2];
			lV[0].setVarRef(0,tag_id);
			lV[1].setParam(0);
			CmvautoPtr<IExprTree> lET( mSession->expr(OP_EQ, 2, lV, 0));

			TVERIFYRC(lQ->addCondition(lVar,lET));		
			TVERIFYRC(defineClass(mSession,className.c_str(), lQ, &lFamilytaggedImagesID));
		}
		TVERIFYRC(mSession->enableClassNotifications(lFamilytaggedImagesID, mNotificationMeta));
	}

	ClassID lCLSSubImageID = STORE_INVALID_CLASSID;//21
	{
		className = string("imageEW") + mPostfix ;
		if(RC_OK!=mSession->getClassID(className.c_str(),lCLSSubImageID))
		{
			CmvautoPtr<IStmt> lQ(mSession->createStmt());
			unsigned char lVar;
			ClassSpec lRange[1];
			lRange[0].classID = lCLSImageID;
			lRange[0].nParams = 0;
			lRange[0].params = NULL;
			lVar = lQ->addVariable(lRange,1);		
		
			// class imagetag() = pin[pin is image()and ((pin has imgStatus_id and imgStatus_id = 0) or !(pin has imgStatus_id))]
			Value lV[2];
			lV[0].setVarRef(0,imgStatus_id);
			IExprTree *lET1 = EXPRTREEGEN(mSession)(OP_EXISTS, 1, lV);

			lV[0].setVarRef(0,imgStatus_id);
			lV[1].set(0);
			IExprTree *lET2 = EXPRTREEGEN(mSession)(OP_EQ, 2, lV);		
			
			lV[0].set(lET1);
			lV[1].set(lET2);
			IExprTree *lET3 = EXPRTREEGEN(mSession)(OP_LAND, 2, lV);	

			lV[0].setVarRef(0,imgStatus_id);
			IExprTree *lET4 = EXPRTREEGEN(mSession)(OP_EXISTS, 1, lV);
			lV[0].set(lET4);
			IExprTree *lET5 = EXPRTREEGEN(mSession)(OP_LNOT, 1, lV);	

			lV[0].set(lET3);
			lV[1].set(lET5);
			CmvautoPtr<IExprTree> lET( mSession->expr(OP_LOR, 2, lV, 0));			

			TVERIFYRC(lQ->addCondition(lVar,lET));
			TVERIFYRC(defineClass(mSession,className.c_str(), lQ, &lCLSSubImageID));
		}
		TVERIFYRC(mSession->enableClassNotifications(lCLSSubImageID, mNotificationMeta));
	}
	
	ClassID lCLSWasteImageID = STORE_INVALID_CLASSID;//22
	{
		className = string("imageW") + mPostfix ;
		if(RC_OK!=mSession->getClassID(className.c_str(),lCLSWasteImageID))
		{
			CmvautoPtr<IStmt> lQ(mSession->createStmt());
			unsigned char lVar;
			ClassSpec lRange[1];
			lRange[0].classID = lCLSImageID;
			lRange[0].nParams = 0;
			lRange[0].params = NULL;
			lVar = lQ->addVariable(lRange,1);		
		
			// class imagetag() = pin[pin is image() and imgStatus = 1]
			Value lV[2];
			lV[0].setVarRef(0,imgStatus_id);
			lV[1].set(1);
			CmvautoPtr<IExprTree> lET( mSession->expr(OP_EQ, 2, lV, 0));

			TVERIFYRC(lQ->addCondition(lVar,lET));
			TVERIFYRC(defineClass(mSession,className.c_str(), lQ, &lCLSWasteImageID));
		}
		TVERIFYRC(mSession->enableClassNotifications(lCLSWasteImageID, mNotificationMeta));
	}

	ClassID lFamilytaggedImagesEWID = STORE_INVALID_CLASSID;//23
	{
		//taggedImagesEW  /pin[pin is imageEW() and prop1 = $tagName]
		className = string("taggedImagesEW") + mPostfix ;
		if(RC_OK!=mSession->getClassID(className.c_str(),lFamilytaggedImagesEWID))
		{
			CmvautoPtr<IStmt> lQ(mSession->createStmt());
			ClassSpec lRange[1];
			lRange[0].classID = lCLSSubImageID;
			lRange[0].nParams = 0;
			lRange[0].params = NULL;
			unsigned const char lVar = lQ->addVariable(lRange,1);		

			Value lV[2];
			lV[0].setVarRef(0,tag_id);
			lV[1].setParam(0);
			CmvautoPtr<IExprTree> lET( mSession->expr(OP_EQ, 2, lV, 0));

			TVERIFYRC(lQ->addCondition(lVar,lET));		
			TVERIFYRC(defineClass(mSession,className.c_str(), lQ, &lFamilytaggedImagesEWID));
		}
		TVERIFYRC(mSession->enableClassNotifications(lFamilytaggedImagesEWID, mNotificationMeta));
	}

	// Create the Family with lCLSSubImageID's class
	ClassID lFamilyID = STORE_INVALID_CLASSID;//24
	{
		// pin is lCLSSubImageID and prop2 IN var1 (range of dates)
		className = string("imageClusterEW") + mPostfix ;
		if(RC_OK!=mSession->getClassID(className.c_str(),lFamilyID))
		{
			CmvautoPtr<IStmt> lQ(mSession->createStmt());
			ClassSpec lRange[1];
			lRange[0].classID = lCLSSubImageID;
			lRange[0].nParams = 0;
			lRange[0].params = NULL;
			unsigned const char lVar = lQ->addVariable(lRange,1);		

			Value lV[2];
			lV[0].setVarRef(0,date_id);
			lV[1].setParam(0);
			CmvautoPtr<IExprTree> lET( mSession->expr(OP_IN, 2, lV, 0));

			TVERIFYRC(lQ->addCondition(lVar,lET));		
			TVERIFYRC(defineClass(mSession,className.c_str(), lQ, &lFamilyID));
		}
		TVERIFYRC(mSession->enableClassNotifications(lFamilyID, mNotificationMeta));
	}

	// Create the Family with lCLSWasteImageID's class
	ClassID lWasteFamilyID = STORE_INVALID_CLASSID;//25
	{
		// pin is lCLSWasteImageID and prop2 IN var1 (range of dates)
		className = string("imageClusterW") + mPostfix ;
		if(RC_OK!=mSession->getClassID(className.c_str(),lWasteFamilyID))
		{
			CmvautoPtr<IStmt> lQ(mSession->createStmt());
			ClassSpec lRange[1];
			lRange[0].classID = lCLSWasteImageID;
			lRange[0].nParams = 0;
			lRange[0].params = NULL;
			unsigned const char lVar = lQ->addVariable(lRange,1);		

			Value lV[2];
			lV[0].setVarRef(0,date_id);
			lV[1].setParam(0);
			CmvautoPtr<IExprTree> lET( mSession->expr(OP_IN, 2, lV, 0));

			TVERIFYRC(lQ->addCondition(lVar,lET));		
			TVERIFYRC(defineClass(mSession,className.c_str(), lQ, &lWasteFamilyID));
		}
		TVERIFYRC(mSession->enableClassNotifications(lWasteFamilyID, mNotificationMeta));
	}

	ClassID lFamilyImageClusterEWCRID = STORE_INVALID_CLASSID;//26
	{
		//imageClusterEWCR  /pin[pin is imageEW() and PROP_SPEC_CREATED in $dateRange]
		className = string("imageClusterEWCR") + mPostfix ;
		if(RC_OK!=mSession->getClassID(className.c_str(),lFamilyImageClusterEWCRID))
		{
			CmvautoPtr<IStmt> lQ(mSession->createStmt());
			ClassSpec lRange[1];
			lRange[0].classID = lCLSSubImageID;
			lRange[0].nParams = 0;
			lRange[0].params = NULL;
			unsigned const char lVar = lQ->addVariable(lRange,1);		

			Value lV[2];
			PropertyID propid = PROP_SPEC_CREATED;
			lV[0].setVarRef(0,propid);
			lV[1].setParam(0);
			CmvautoPtr<IExprTree> lET( mSession->expr(OP_IN, 2, lV, 0));

			TVERIFYRC(lQ->addCondition(lVar,lET));
			TVERIFYRC(defineClass(mSession,className.c_str(), lQ, &lFamilyImageClusterEWCRID));
		}
		TVERIFYRC(mSession->enableClassNotifications(lFamilyImageClusterEWCRID, mNotificationMeta));
	}

	ClassID lFamilyImageClusterWCRID = STORE_INVALID_CLASSID;//27
	{
		//imageClusterWCR  /pin[pin is imageW() and PROP_SPEC_CREATED in $dateRange]
		className = string("imageClusterWCR") + mPostfix ;
		if(RC_OK!=mSession->getClassID(className.c_str(),lFamilyImageClusterWCRID))
		{
			CmvautoPtr<IStmt> lQ(mSession->createStmt());
			ClassSpec lRange[1];
			lRange[0].classID = lCLSWasteImageID;
			lRange[0].nParams = 0;
			lRange[0].params = NULL;
			unsigned const char lVar = lQ->addVariable(lRange,1);		

			Value lV[2];
			PropertyID propid = PROP_SPEC_CREATED;
			lV[0].setVarRef(0,propid);
			lV[1].setParam(0);
			CmvautoPtr<IExprTree> lET( mSession->expr(OP_IN, 2, lV, 0));

			TVERIFYRC(lQ->addCondition(lVar,lET));
			TVERIFYRC(defineClass(mSession,className.c_str(), lQ, &lFamilyImageClusterWCRID));
		}
		TVERIFYRC(mSession->enableClassNotifications(lFamilyImageClusterWCRID, mNotificationMeta));
	}

	ClassID lFamilyFileImageID = STORE_INVALID_CLASSID;//28
	{
		//fileimage  /pin[pin is importedFile() and fs_path = $path]
		className = string("fileimage") + mPostfix ;
		if(RC_OK!=mSession->getClassID(className.c_str(),lFamilyFileImageID))
		{
			CmvautoPtr<IStmt> lQ(mSession->createStmt());
			ClassSpec lRange[1];
			lRange[0].classID = lCLSImportedFileID;
			lRange[0].nParams = 0;
			lRange[0].params = NULL;
			unsigned const char lVar = lQ->addVariable(lRange,1);		

			Value lV[2];
			lV[0].setVarRef(0,fs_path_id);
			lV[1].setParam(0);
			CmvautoPtr<IExprTree> lET( mSession->expr(OP_EQ, 2, lV, 0));

			TVERIFYRC(lQ->addCondition(lVar,lET));
			TVERIFYRC(defineClass(mSession,className.c_str(), lQ, &lFamilyFileImageID));
		}
		TVERIFYRC(mSession->enableClassNotifications(lFamilyFileImageID, mNotificationMeta));
	}

	ClassID lCLSTabInfoID = STORE_INVALID_CLASSID; //29
	{
		//mv:defineclass("tabinfo","/pin[pin has tabname]",0)
		className = string("tabinfo") + mPostfix ;
		if(RC_OK!=mSession->getClassID(className.c_str(),lCLSTabInfoID))
		{
			CmvautoPtr<IStmt> lQ(mSession->createStmt());
			unsigned const char lVar = lQ->addVariable();
			Value lV[1];
			lV[0].setVarRef(0,tabname_id);
			CmvautoPtr<IExprTree> lET( mSession->expr(OP_EXISTS, 1, lV, 0));
			TVERIFYRC(lQ->addCondition(lVar,lET));

			TVERIFYRC(defineClass(mSession,className.c_str(), lQ, &lCLSTabInfoID));
		}
		TVERIFYRC(mSession->enableClassNotifications(lCLSTabInfoID, mNotificationMeta));
	}

	ClassID lCLSOwnerInfoID = STORE_INVALID_CLASSID; //30
	{
		//mv:defineclass("ownerinfo","/pin[pin has owner_id and pin has owner_name]",0)
		className = string("list") + mPostfix ;
		if(RC_OK!=mSession->getClassID(className.c_str(),lCLSOwnerInfoID))
		{
			CmvautoPtr<IStmt> lQ(mSession->createStmt());
			unsigned const char lVar = lQ->addVariable();
			Value lV[2];
			lV[0].setVarRef(0,owner_id_id);
			IExprTree *lET1 = EXPRTREEGEN(mSession)(OP_EXISTS, 1, lV);

			lV[0].setVarRef(0,owner_name_id);
			IExprTree *lET2 = EXPRTREEGEN(mSession)(OP_EXISTS, 1, lV);

			lV[0].set(lET1);
			lV[1].set(lET2);
			CmvautoPtr<IExprTree> lET( mSession->expr(OP_LAND, 2, lV, 0));
			TVERIFYRC(lQ->addCondition(lVar,lET));

			TVERIFYRC(defineClass(mSession,className.c_str(), lQ, &lCLSOwnerInfoID));
		}
		TVERIFYRC(mSession->enableClassNotifications(lCLSOwnerInfoID, mNotificationMeta));
	}

	ClassID lFamilyAllImportedFilesID = STORE_INVALID_CLASSID;//31
	{
		//allImportedFiles  /pin[pin is importedFile() and fs_path begins with $folder]		
		className = string("allImportedFiles") + mPostfix ;
		if(RC_OK!=mSession->getClassID(className.c_str(),lFamilyAllImportedFilesID))
		{
			CmvautoPtr<IStmt> lQ(mSession->createStmt());
			ClassSpec lRange[1];
			lRange[0].classID = lCLSImportedFileID;
			lRange[0].nParams = 0;
			lRange[0].params = NULL;
			unsigned const char lVar = lQ->addVariable(lRange,1);		

			Value lV[2];
			lV[0].setVarRef(0,fs_path_id);
			lV[1].setParam(0);
			CmvautoPtr<IExprTree> lET( mSession->expr( OP_BEGINS, 2, lV, 0));

			TVERIFYRC(lQ->addCondition(lVar,lET));		
			TVERIFYRC(defineClass(mSession,className.c_str(), lQ, &lFamilyAllImportedFilesID));
		}
		TVERIFYRC(mSession->enableClassNotifications(lFamilyAllImportedFilesID, mNotificationMeta));
	}
}

IStmt * PhotoScenario::createClassQuery
( 
	const char * inClassName,			// Name of class
	STMT_OP sop,
	unsigned int inCntVars,
	Value * inVars,						// Optional variables for Family queries
	unsigned int inCntOrderProps,
	const OrderSeg * inOrder,			// Optional sorting info
	const char * inFTSearch			// Optional full text search within the class
)
{
	// Convenient function for creating a query on top of one of the classes or families
	// generated in createPhotoClasses
	// This version relies on the default session for single threaded tests
	return createClassQueryS( mSession, inClassName, sop, inCntVars, inVars, inCntOrderProps, inOrder, inFTSearch ) ;
}

IStmt * PhotoScenario::createClassQueryS
( 
	ISession* inSession,
	const char * inClassName,			// Name of class
	STMT_OP sop,
	unsigned int inCntVars,				
	Value * inVars,						// Optional variables for Family queries
	unsigned int inCntOrderProps,
	const OrderSeg * inOrder,			// Optional sorting info
	const char * inFTSearch			// Optional full text search within the class
)
{
	ClassID cls = getClass(inClassName,inSession) ;
	TVERIFY( cls != STORE_INVALID_CLASSID ) ;
	IStmt * q = inSession->createStmt(sop) ;

	ClassSpec classInfo;
	classInfo.classID = cls;
	classInfo.nParams = inCntVars;
	classInfo.params = inVars;

	unsigned const char variable0 = q->addVariable(&classInfo,1);		

	if ( inFTSearch )
		q->setConditionFT( variable0, inFTSearch ) ;
	
	if ( inCntOrderProps > 0 )
	{
		q->setOrder(inOrder, inCntOrderProps ) ;
	}

	return q ;
}



void  PhotoScenario::runClassQueries()
{
	// Test some basic expectations about the class queries
	// and print out information about the random pin data

	mLogger.out() << "Running class queries..." << endl ;

	uint64_t cntQ = 0 ;

	uint64_t cntImages = 0 ;
	CmvautoPtr<IStmt> qImage(createClassQuery( "image" ) );
	TVERIFYRC(qImage->count(cntImages)) ;

	uint64_t cntImagesEW = 0 ;
	CmvautoPtr<IStmt> qImageEW(createClassQuery( "imageEW" ) );
	TVERIFYRC(qImageEW->count(cntImagesEW)) ;

	uint64_t cntImagesW = 0 ;
	CmvautoPtr<IStmt> qImageW(createClassQuery( "imageW" ) );
	TVERIFYRC(qImageW->count(cntImagesW)) ;

	mLogger.out() <<"\t"<< cntImages << " pins in 'image' class (" << cntImagesW << " waste, " << cntImagesEW <<  " excluding waste)"<< endl ;
	TVERIFY( cntImagesW + cntImagesEW == cntImages ) ;


	CmvautoPtr<IStmt> qImportedFile(createClassQuery( "importedFile" ) );
	TVERIFYRC(qImportedFile->count(cntQ)) ;
	mLogger.out() <<"\t"<< cntQ << " pins in 'importedFile' class" << endl ;

	CmvautoPtr<IStmt> qTagged(createClassQuery( "taggedPin" ) );
	TVERIFYRC(qTagged->count(cntQ)) ;
	mLogger.out() <<"\t"<< cntQ << " pins in 'taggedPin' class" << endl ;

	for ( size_t i = 0 ; i < mTagPool.size() ; i++ )
	{
		Value tag ; tag.set( mTagPool[i].c_str() ) ;

		OrderSeg ord = {NULL,date_id,0,0};
		CmvautoPtr<IStmt> qTags(createClassQuery( "taggedImages",STMT_QUERY,1,&tag,1,&ord ) );
		qTags->count( cntQ ) ;
		TVERIFY( cntQ > 0 ) ;

		CmvautoPtr<IStmt> qTagsEW(createClassQuery( "taggedImagesEW",STMT_QUERY,1,&tag,1,&ord ) );
		uint64_t cntQEW ;
		qTagsEW->count( cntQEW ) ;
		TVERIFY( cntQEW <= cntQ ) ;

		mLogger.out() <<"\t"<<"\t"<< cntQ << " pins have tag " << mTagPool[i].c_str() << " (" << cntQEW << " excluding Waste images)" << endl ;
	}
}
bool PhotoScenario::createAppPINs()
{
	// REVIEW: This creates more PINs than are closer to the photo app pins,
	// with folder and feed pins as well.
	// todo: merge with addPhotoPin and have enough flags to control
	// certain aspects that may or may not be needed by each test.

	bool lSuccess = true;	
	IPIN * lPIN = NULL;
	std::vector<IPIN *> lClusterPINs;
	const int sClusterSize = mNumPINsPerFolder;
	int i, k;
	size_t y = 0;
	Tstring lTagStr;
	char *pFolderName = NULL;

	// Create Tags to be added to the Image PINs
	for(i = 0; i < (int)mTagCount; i++)
	{
		createTagPIN();
	}
	
	int lNumTags = 0;
	for(i = 0, k = 1, y = 0; i < (int)mPinCount; i++, k++)
	{		
		int strLen = 0;		
		Value *lPVs = (Value *)mSession->alloc(24*sizeof(Value));		
		if(k==1) 
		{
			mLogger.out() << "Creating cloud of " << sClusterSize << " PINs ...";
			y = y<mFolderCount?y:0;
			pFolderName = (char *)mFilePathPool[y++].c_str();
			lNumTags = MVTRand::getRange((int)mTagCount/4,(int)mTagCount);
		}
		if(i%100 == 0) mLogger.out() << ".";

		strLen = (int)strlen(pFolderName) + 1;
		char *tmpFolderPath = (char*)mSession->alloc(sizeof(char)*(strLen));
		strcpy(tmpFolderPath,pFolderName);
		SETVALUE(lPVs[0],fs_path_id,tmpFolderPath,OP_SET); // fs_path 

		const char * lTmpMimeStr = "image/jpeg";
		strLen = (int)strlen(lTmpMimeStr) + 1;
		char *lMimeStr = (char*)mSession->alloc(sizeof(char)*(strLen));
		strcpy(lMimeStr,lTmpMimeStr);
		SETVALUE(lPVs[1],mime_id,lMimeStr,OP_SET);lPVs[1].setMeta(META_PROP_NOFTINDEX); // mime

		Tstring lTmpFileName;MVTRand::getString(lTmpFileName,15,50,false,false);
		lTmpFileName += ".JPG" ;
		strLen = (int)lTmpFileName.length() + 1;
		char *lFileName = (char*)mSession->alloc(sizeof(char)*(strLen));
		strcpy(lFileName,lTmpFileName.c_str());
		SETVALUE(lPVs[2],name_id,lFileName,OP_SET); // name

		uint64_t lDT = MVTRand::getDateTime(mSession,false); 
		lPVs[3].setDateTime(lDT); lPVs[3].setPropID(lastmodified_id);// lastmodified

		lDT = MVTRand::getDateTime(mSession,false);
		lPVs[4].setDateTime(lDT); lPVs[4].setPropID(created_id); // created

		int lSize = (int) ((float)40000 * rand()/RAND_MAX);
		IStream *lStream1 = MVTApp::wrapClientStream(mSession, new PhotoScenarioStream(lSize > 0? lSize:800));
		lPVs[5].set(lStream1);lPVs[5].setPropID(binary_id);lPVs[5].setMeta(META_PROP_NOFTINDEX |META_PROP_SSTORAGE); //binary

		lDT = MVTRand::getDateTime(mSession,false); 
		lPVs[6].setDateTime(lDT) ;lPVs[6].setPropID(date_id); //date

		const char * lTmpModelStr = "Nikon";
		strLen = (int)strlen(lTmpModelStr) + 1;
		char *lModelStr = (char*)mSession->alloc(sizeof(char)*(strLen));
		strcpy(lModelStr,lTmpModelStr);
		SETVALUE(lPVs[7],exif_model_id,lModelStr,OP_SET); //exif_model

		SETVALUE(lPVs[8],exif_fnumber_id,float(1.0),OP_SET); //exif_fnumber

		lDT = MVTRand::getDateTime(mSession,false); 
		lPVs[9].setDateTime(lDT); lPVs[9].setPropID(exif_picturetaken_id); // exif_picturetaken

		SETVALUE(lPVs[10],exif_exposuretime_id,(float)MVTRand::getRange(1,2),OP_SET); //exif_exposuretime

		SETVALUE(lPVs[11],exif_isospeedratings_id, MVTRand::getRange(0,2),OP_SET); //exif_isospeedratings

		SETVALUE(lPVs[12],exif_flash_id,MVTRand::getRange(0,2),OP_SET); // exif_flash

		SETVALUE(lPVs[13],width_id,MVTRand::getRange(860,1024),OP_SET);// width

		SETVALUE(lPVs[14],height_id,MVTRand::getRange(860,1024),OP_SET); // height

		lSize = (int) ((float)1000 * rand()/RAND_MAX); // preview
		IStream *lStream2 = MVTApp::wrapClientStream(mSession, new PhotoScenarioStream(lSize > 0? lSize:400));
		lPVs[15].set(lStream2);lPVs[15].setPropID(preview_id);lPVs[15].setMeta(META_PROP_NOFTINDEX|META_PROP_SSTORAGE);

		const char * lTmpMakeStr = "Junk";
		strLen = (int)strlen(lTmpMakeStr) + 1;
		char *lMakeStr = (char*)mSession->alloc(sizeof(char)*(strLen));
		strcpy(lMakeStr,lTmpMakeStr);		
		SETVALUE(lPVs[16],exif_make_id,lMakeStr,OP_SET); // exif_make

		const char * lTmpNodeStr = "007-pinode.mvstore.org";
		strLen = (int)strlen(lTmpNodeStr) + 1;
		char *lNodeStr = (char*)mSession->alloc(sizeof(char)*(strLen));
		strcpy(lNodeStr,lTmpNodeStr);		
		SETVALUE(lPVs[17],refreshNodeID_id,lNodeStr,OP_SET);lPVs[17].setMeta(META_PROP_NOFTINDEX); // refresh-node-id

		SETVALUE(lPVs[18],exif_width_id,MVTRand::getRange(860,1024),OP_SET); // exif_width

		SETVALUE(lPVs[19],exif_height_id,MVTRand::getRange(860,1024),OP_SET);	// exif_height

		Tstring lTmpPathIndexStr; MVTRand::getString(lTmpPathIndexStr,15,200,false,false); // fs_path_index
		strLen = (int)lTmpPathIndexStr.length() + 1;
		char *lTmpPathIndex = (char*)mSession->alloc(sizeof(char)*(strLen));
		strcpy(lTmpPathIndex,lTmpPathIndexStr.c_str());
		SETVALUE(lPVs[20],fs_path_index_id,lTmpPathIndex,OP_SET);

		const char * lTmpSourceNodeStr = "008-pinode.mvstore.org";
		strLen = (int)strlen(lTmpSourceNodeStr) + 1;
		char *lSourceNodeStr = (char*)mSession->alloc(sizeof(char)*(strLen));
		strcpy(lSourceNodeStr,lTmpSourceNodeStr);		
		SETVALUE(lPVs[21],sourcenode_id,lSourceNodeStr,OP_SET);lPVs[21].setMeta(META_PROP_NOFTINDEX); // sourcenode 

		SETVALUE(lPVs[22],PROP_SPEC_CREATED,1,OP_SET); // PROP_SPEC_CREATED

		SETVALUE(lPVs[23],cache_id,0,OP_SET); // cache

		lPIN = mSession->createUncommittedPIN(lPVs,24);
		
		// Add Tags to the Image PIN
		{			
			int j = 0;
			Value *lTagVal = (Value *)mSession->alloc(lNumTags*sizeof(Value));
			char *lTag = NULL;
			for(j = 0; j < lNumTags; j++)
			{
				lTag = (char *)mSession->alloc((mTagPool[j].length() + 1)*sizeof(char));
				strcpy(lTag, mTagPool[j].c_str());
				SETVALUE_C(lTagVal[j],tag_id,lTag,OP_ADD,STORE_COLLECTION_ID);
			}
			if(RC_OK!=lPIN->modify(lTagVal,lNumTags)) assert(false);
			for(j = 0; j < lNumTags; j++)
			{
				if(lTagVal[j].type == VT_STRING)
				{
					const char *pTempStr = lTagVal[j].str;
					mSession->free((void *)pTempStr);
				}
			}
			mSession->free(lTagVal);

			// Add ACLs if notification is disabled. Notification adds ACLs otherwise
			if(mCreateACLs)
			{
				Value *lACLVal = (Value *)mSession->alloc(1*sizeof(Value));
				RefVID *lRef = (RefVID *)mSession->alloc(1*sizeof(RefVID));
				for(j = 0; j < lNumTags; j++)
				{
					RefVID l = {mTagPINs[0], PROP_SPEC_ACL, STORE_COLLECTION_ID, STORE_CURRENT_VERSION};
					*lRef = l;
					lACLVal[0].set(*lRef); lACLVal[0].setPropID(PROP_SPEC_ACL); lACLVal[0].op = OP_ADD;
					if(RC_OK!=lPIN->modify(lACLVal,1)) assert(false);
				}
				mSession->free(lRef);
				mSession->free(lACLVal);
			}					

			lClusterPINs.push_back(lPIN);
		}

		if(k == sClusterSize || i == int(mPinCount-1))
		{
			if(RC_OK != mSession->commitPINs(&lClusterPINs[0],k==sClusterSize?sClusterSize:k)){
				mLogger.out() << "ERROR (PhotoScenario::createAppPINs): Failed to commit cluster of pins " << std::endl;
				lSuccess = false;
			}
			else
			{				
				// Create a Feed PIN and a Folder PIN for every commitPINs()				
				int lIndex = 0;
				PID lFeedPID = createFeedPIN(pFolderName);
				PID lFolderPID = createFolderPIN(lFeedPID, pFolderName);
				IPIN *lPIN = mSession->getPIN(lFolderPID);

				/* Adding the Image PINs as posts to the Folder PIN */
				Value *lPVs = (Value *)mSession->alloc((mNumPINsPerFolder+1)*sizeof(Value));
				for(lIndex = 0; lIndex < (k==sClusterSize?sClusterSize:k); lIndex++) 
				{					
					PID lPID = lClusterPINs[lIndex]->getPID();
					SETVALUE_C(lPVs[lIndex],posts_id,lPID,OP_ADD_BEFORE,STORE_FIRST_ELEMENT); 
					lClusterPINs[lIndex]->destroy();
					mPids.push_back(lPID);
					
				}
				/* This is a workaround for the BIG Collection issue. If list of values are passed to IPIN::modify(), RC_NORESOURCES is returned.
				So passing the values as VT_ARRAY */
				RC lRC;
				Value lV[1];
				lV[0].set(lPVs,k==sClusterSize?sClusterSize:k);lV[0].setPropID(posts_id);
				lV[0].op = OP_ADD_BEFORE; lV[0].eid = STORE_LAST_ELEMENT;
				if(RC_OK!=(lRC=lPIN->modify(lV,1)))
				{
					mLogger.out() << "ERROR (PhotoScenario::createAppPINs): Failed to modify folder pin  with RC = " << lRC << std::endl;
				}
				lPIN->destroy();
				mSession->free(lPVs);				
				lClusterPINs.clear();
				k = 0;
				mLogger.out() << " DONE" <<std::endl;
			}
		}		
			
	}
	return lSuccess;
}

PID PhotoScenario::createFeedPIN(const char *pFolderName)
{
	PID lFeedPID; INITLOCALPID(lFeedPID);
	Value lPVs[7];

	SETVALUE(lPVs[0],feedtype_id,1,OP_SET);
	SETVALUE(lPVs[1],feedinfo_id, pFolderName, OP_SET); // feedinfo
	SETVALUE(lPVs[2],feedautorefresh_id,0,OP_SET); // feedautorefresh
	SETVALUE(lPVs[3],feedfullsize_id,0,OP_SET); // feedfullsize
	SETVALUE(lPVs[4],feedimportsubfolder_id,0,OP_SET); // feedimportsubfolder
	SETVALUE(lPVs[5],feedflattensubfolder_id,0,OP_SET); // feedflattensubfolder
	SETVALUE(lPVs[6],autogen_id,1,OP_SET); // autogen
	
	if(RC_OK !=  mSession->createPIN(lFeedPID,lPVs,7))
	{
		mLogger.out() << "ERROR (createFeedPIN): Failed to create feed PIN of foldername = " << pFolderName << std::endl;		
	}
	return lFeedPID;
}

PID PhotoScenario::createFolderPIN(PID pPID, const char *pFolderName)
{
	int strLen = 0;
	PID lFolderPID; INITLOCALPID(lFolderPID);

	Value *lPVs = (Value *)mSession->alloc(10*sizeof(Value));

	strLen = (int)strlen(pFolderName) + 1;
	char *lFolderName = (char *)mSession->alloc(strLen*sizeof(char));
	strcpy(lFolderName, pFolderName);
	SETVALUE(lPVs[0],name_id,lFolderName,OP_SET); //name

	char *lShortName = (char *)mSession->alloc(strLen*sizeof(char));
	strcpy(lShortName, pFolderName);
	SETVALUE(lPVs[1],shortname_id,lShortName,OP_SET); //shortname

	const char *lTmpContent = "\0";
	char * lContent = (char *)mSession->alloc((strlen(lTmpContent) + 1)*sizeof(char));
	strcpy(lContent, lTmpContent);
	SETVALUE(lPVs[2],content_id,lContent,OP_SET); // content

	SETVALUE(lPVs[3],autogenerated_id,1,OP_SET); // autogenerated
	SETVALUE(lPVs[4],photo_count_id,0,OP_SET); //photo_count

	char *lFSName = (char *)mSession->alloc(strLen*sizeof(char));
	strcpy(lFSName, pFolderName);
	SETVALUE(lPVs[5],fs_folder_id,lFSName,OP_SET); //fs_folder

	SETVALUE(lPVs[6],PROP_SPEC_UPDATED,1,OP_SET); //PROP_SPEC_UPDATED
	SETVALUE(lPVs[7],feed_id,pPID,OP_SET); //feed
	SETVALUE(lPVs[8],album_count_id,0,OP_SET); //album_count
	SETVALUE(lPVs[9],feedtype_id,1,OP_SET); // feedtype

	IPIN *lPIN = mSession->createUncommittedPIN(lPVs,10);

	if(RC_OK !=  mSession->commitPINs(&lPIN,1))
	{
		mLogger.out() << "ERROR (createFolderPIN): Failed to create Folder PIN: foldername = " << pFolderName << std::endl;		
	}
	else
	{
		lFolderPID = lPIN->getPID();
		lPIN->destroy();
	}
	return lFolderPID;
}

PID PhotoScenario::createTagPIN(const char *pTagName)
{
	PID lTagPID; INITLOCALPID(lTagPID);
	Tstring lTagStr;
	if(pTagName)
		lTagStr = pTagName;
	else
		MVTRand::getString(lTagStr,10,10,false,false);

	if(mCreateTagPINs)
	{	
		Value *lPVs = (Value *)mSession->alloc(4*sizeof(Value));						
		
		int strLen = (int)lTagStr.length()+1;
		char *tmpName = (char*)mSession->alloc(sizeof(char)*(strLen));
		strcpy(tmpName,lTagStr.c_str());

		char *tmpShortName = (char*)mSession->alloc(sizeof(char)*(strLen));
		strcpy(tmpShortName,lTagStr.c_str());

		SETVALUE(lPVs[0],tagword_id,tmpName,OP_SET);
		SETVALUE(lPVs[1],shortname_id,tmpShortName,OP_SET);
		SETVALUE(lPVs[2],tagcount_id,0,OP_SET);
		SETVALUE(lPVs[3],PROP_SPEC_UPDATED,1,OP_SET);
		if(RC_OK !=  mSession->createPIN(lTagPID,lPVs,4))
			assert(false);
		else
			mTagPINs.push_back(lTagPID);
		
		int k = 0;
		for(k = 0; k < 4; k++)
		{
			if(lPVs[k].type == VT_STRING)
			{
				const char *pTempStr = lPVs[k].str;
				mSession->free((void *)pTempStr);
			}
		}
		mSession->free(lPVs);		
	}
	mTagPool.push_back(lTagStr); // List of candidate tags is built even if pins aren't added
	return lTagPID;
}
